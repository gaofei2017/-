#框架封装-选择器模块
##1. git知识补充
  	1.1在 git 提交的时候, 如果在 项目的目录中提供一个 .gitignore 文件, 
  	里面放置的是不需要提交的文件名那么在文件提交的时候就会忽略该文件的描述的内容.
	1.2 创建 以 . 开头的文件, 在 win 中有两个常用的办法
		1> 使用名字  .gitignore.
		2> 使用命令 touch .gitignore
	1.3 删除分支的时候, 如果分支没有合并会给出警告不允许删除 可以使用 branch -D强制删除
##2.eval() new Function() json 冒泡排序
这个函数可以将 js 格式的字符串作为代码来执行( 其它编程语言中称为 反射 )
        在代码中, 凡是使用 eval 函数的地方就与直接执行 js 代码是一样的

        例如:

        var num = 123;
        eval( 'var res = num + 1' );
        console.log( res );        

        等价

        var num = 123;
        var res = num + 1; 
        console.log( res );        

        eval 很强大, 而且很灵活. 正因为其强大与灵活, 使得可以实现任意的代码. 即使 是 恶意代码.
        所以在开发过程中不推荐使用 eval.

        在使用 eval 时, 早期最多的是将 ajax 返回的字符串转换成对象.
        var json = '{ name:"jim", age: 19, gender: "男" }';
        var o = eval( '(' + json + ')' );
        如果不加 (), 那么 eval 将花括号作为 语句块来解释, 因此语法错误, 那么加上 () 以后, 
        花括号就作为表达式解析, 那么就是对象的含义了. 因此不会出现错误.

        但是今天 ES5 中引入了 JSON 对象. 利用 JSON 的 parse 和 stringify 可以将字符串转换成对象,
        或将对象转换成字符串. 在使用 JSON 方法的时候, 字符串必须是符合 JSON 格式的( 严格要求 ).

        eval 很强大, 但是不推荐使用, 我要实现类似功能怎么办呢? 推荐使用 Function 作为构造函数,
        来生成函数执行字符串.
        var json = '{ name:"jim", age: 19, gender: "男" }';

        构造一个函数
        new Function ( 'return ' + json )

        等价于
        function ??? ( ) {
            return { name:"jim", age: 19, gender: "男" }
        }
        利用 new Function 来实现数组的排序.
        var arr = [ ... ]
        for ( var i = 0; i < arr.length - 1; i++ ) {
            for ( var j = 0; j < arr.length - 1 - i; j++ ) {
                if ( arr[ j ] > arr[ j + 1] ) {
                    ...
                }
            }
        }

        var sort = new Function ( 'arr', 'for ( var i = 0; i < arr.length - 1; i++ ) {' +
                                         'for ( var j = 0; j < arr.length - 1 - i; j++ ) {' + 
                                         ... );

        因此使用语法:
        var obj = (new Function ( 'return ' + json ))();
        来得到转换的 对象.
        jq 中 each, map 与 ES5 中扩展的 forEach 和 map 的异同
	        jq:
		        each: 数组, 对象, 回调函数的参数是(i,v)return false跳出循环, 返回值是遍历的对象本身, this指遍历的当前元素 
		        	  $.each( 数组或对象, callback ) 在内部会遍历 "数组及对象" 的每一个成员
	                  如果遍历的是数组, 那么遍历的就是数组中的每一个 [ i ] 的元素( 注意其他成员不遍历 )
	                  如果遍历的是对象, 那么就会将对象的所有成员都遍历出来( 包括下标的数据, 和方法属性等 )
	                    例如:
	                        var arr = [ 1, 2, 3 ];
	                        var o = { name: 'jim', '0': '123', sayHello: function () { ... } };
	            	在遍历数据的时候会使用回调函数处理每一个被遍历的元素
	                回调函数默认有两个参数, 他们是该数据在数组中的索引, 以及被遍历的数据
		            for ( var i= 0; i < arr.length; i++ ) {
		                console.log( arr[ i ] + ', ' + i );
		            }

		            可以使用
		            $.each( arr, function ( i, v ) {
		                console.log( v + ', ' + i );
		            });
		        map: 数组, 对象, 确定是否要返回数据, 返回新数组,没有return则返回空数组[].
		        	 也可以实现遍历. 在 jq 中 map 还有一个非常重要的功能就是将一个数组( 对象 )变成另一个数组( 对象 )
            		 例如: [ 1, 2, 3 ] 规则: 将所有的数字扩大一倍 -> [ 2, 4, 6 ]

			            用法:
			                $.map( 数组或对象, callback );
			                内部会遍历数组或对象, 并使用回调函数处理每一个遍历的元素. 
			                注意: 和 each 类似, map 也会遍历每一个元素. 但是不同点是
			                1> 回调函数的参数: v, i
			                2> map 方法会返回一个新数组, 数组元素由每一个回调函数的返回值决定

			                var arr = [1,2,3];
			                var newArr = $.map( arr, function ( v, i ) {
			                    // return v * 2;
			                });
	        ES5:
		        	在数组中所有的遍历方法都有同一种调用形式数组.XXX( callback );并且回调函数的参数都是 v, i. 同时不能使用 this.

	        .map
	            var newArr = arr.map( function ( v, i ) {
	                return ...;
	            });
	            注意: 如果没有 return, 那么相当于 return 了 undefiend

	        .forEach
	            和 jq 中的 each 几乎一样
	            1> 回调函数的参数 v, i
	            2> 数组的 forEach 没有返回值
	            3> 数组中的 forEach 没有跳出语法
	            4> 没有 this 的使用方法

	        .filter
	            含义过滤. 含义是 利用回调函数判断每一个元素, 如果符合要求就保留下来构成一个新的数组
	            arr.filter( function ( v, i ) {
	                判断, 返回 bool 值
	            });
	            如果返回的是 true 那么该数据就会被保留下来

	        .some   (一真则真)
	            判断数组中是否有符合数据要求的项, 如果含有就返回 true, 否则返回 false( 全部元素都不符合要求 )
	        .every  (一假则假)	
	            判断数组中的每一个元素是否都满足条件, 如果有一个不满足就返回 false, 全部满足就返回 true.
	            forEach: 只能是数组, 不能跳出, 不能用 this, 不能返回数据等
	            map: 
	    
##2. pre 标签
预格式化标签. 在 html 中所有的 空白, 空行等字符会被忽略.有些字符也会出现转义. 例如需要在 html 中展示一段代码
        
        例如:
        function func() {
            console.log( '123' )
        }
        在 html 中需要写成这样:
        function&nbsp;func()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;console.log(&nbsp;'123'&nbsp;)<br />
        }

        需要一种标签, 保留我们描述的空白等字符
        <pre></pre>
        <textarea></textarea>
##3. 如何判断对象是一个数组或伪数组
	1> 是不是一个数组
        toString.call() -> '[object Object]' 形式给出
        instanceof 方法也可以实现, 但是在 html 嵌套的页面中会有问题
        Object.prototype.toString.call( arr ) == '[object Array]'
    
    2> 是不是伪数组?
        1) 必须含有 length 属性
            'length' in arr
            这里的in操作符是判断 arr中是否含有length属性
        2) 判断他是不是数字
            typeof length == 'number'
        3) 因此长度需要 非负
            length >= 0
        
        var length = 'length' in arr && arr.length;
        return typeof length === 'number' && length >= 0;

	    function isArrayLike( obj ) {
	        if ( Object.prototype.toString.call( obj ) == '[object Array]' ) {
	            return true;
	        }
	        var length = 'length' in arr && arr.length;
	        return typeof length === 'number' && length >= 0;
	    }
